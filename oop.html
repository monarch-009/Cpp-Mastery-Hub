<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Object-Oriented Programming - C++ Mastery Hub</title>
    <link rel="stylesheet" href="style.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Fira+Code:wght@300;400;500&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
    <link rel="icon" type="image/x-icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ðŸš€</text></svg>">
</head>
<body>
    <nav class="navbar">
        <div class="nav-container">
            <div class="nav-logo">
                <i class="fas fa-code"></i>
                <span>C++ Mastery Hub</span>
            </div>
            <ul class="nav-menu">
                <li class="nav-item">
                    <a href="index.html" class="nav-link">Home</a>
                </li>
                <li class="nav-item dropdown">
                    <a href="#" class="nav-link active">Topics <i class="fas fa-chevron-down"></i></a>
                    <div class="dropdown-content">
                        <a href="basics.html">Basics</a>
                        <a href="oop.html" class="active">OOP</a>
                        <a href="advanced.html">Advanced</a>
                        <a href="stl.html">STL</a>
                    </div>
                </li>
                <li class="nav-item">
                    <a href="projects.html" class="nav-link">Projects</a>
                </li>
                <li class="nav-item">
                    <a href="quiz.html" class="nav-link">Quiz</a>
                </li>
                <li class="nav-item">
                    <button class="theme-toggle" id="themeToggle">
                        <i class="fas fa-moon"></i>
                    </button>
                </li>
            </ul>
            <div class="hamburger">
                <span class="bar"></span>
                <span class="bar"></span>
                <span class="bar"></span>
            </div>
        </div>
    </nav>

    <div class="page-container">
        <aside class="sidebar">
            <div class="sidebar-content">
                <h3>Table of Contents</h3>
                <ul class="toc">
                    <li><a href="#introduction">Introduction to OOP</a></li>
                    <li><a href="#classes-objects">Classes & Objects</a></li>
                    <li><a href="#constructors">Constructors & Destructors</a></li>
                    <li><a href="#access-modifiers">Access Modifiers</a></li>
                    <li><a href="#inheritance">Inheritance</a></li>
                    <li><a href="#polymorphism">Polymorphism</a></li>
                    <li><a href="#encapsulation">Encapsulation</a></li>
                    <li><a href="#abstraction">Abstraction</a></li>
                    <li><a href="#virtual-functions">Virtual Functions</a></li>
                </ul>
            </div>
        </aside>

        <main class="main-content">
            <div class="content-header">
                <h1>Object-Oriented Programming</h1>
                <p>Master the principles of OOP in C++</p>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
            </div>

            <div class="content-sections">
                <!-- Introduction to OOP -->
                <section class="content-section" id="introduction">
                    <div class="accordion-item">
                        <div class="accordion-header" >
                            <h2><i class="fas fa-cube"></i> Introduction to OOP</h2>
                            <i class="fas fa-chevron-down"></i>
                        </div>
                        <div class="accordion-content">
                            <div class="topic-content">
                                <p>Object-Oriented Programming (OOP) is a programming paradigm that organizes code around objects and classes rather than functions and logic.</p>
                                
                                <h3>Four Pillars of OOP:</h3>
                                <div class="oop-pillars">
                                    <div class="pillar-card">
                                        <div class="pillar-icon">
                                            <i class="fas fa-box"></i>
                                        </div>
                                        <h4>Encapsulation</h4>
                                        <p>Bundling data and methods that operate on that data within a single unit (class)</p>
                                    </div>
                                    <div class="pillar-card">
                                        <div class="pillar-icon">
                                            <i class="fas fa-sitemap"></i>
                                        </div>
                                        <h4>Inheritance</h4>
                                        <p>Creating new classes based on existing classes, inheriting their properties and methods</p>
                                    </div>
                                    <div class="pillar-card">
                                        <div class="pillar-icon">
                                            <i class="fas fa-shapes"></i>
                                        </div>
                                        <h4>Polymorphism</h4>
                                        <p>The ability of objects to take multiple forms and behave differently based on context</p>
                                    </div>
                                    <div class="pillar-card">
                                        <div class="pillar-icon">
                                            <i class="fas fa-eye-slash"></i>
                                        </div>
                                        <h4>Abstraction</h4>
                                        <p>Hiding complex implementation details while showing only essential features</p>
                                    </div>
                                </div>

                                <div class="info-box">
                                    <i class="fas fa-lightbulb"></i>
                                    <p><strong>Benefits of OOP:</strong> Code reusability, modularity, easier maintenance, better organization, and real-world modeling.</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </section>

                <!-- Classes & Objects -->
                <section class="content-section" id="classes-objects">
                    <div class="accordion-item">
                        <div class="accordion-header" >
                            <h2><i class="fas fa-building"></i> Classes & Objects</h2>
                            <i class="fas fa-chevron-down"></i>
                        </div>
                        <div class="accordion-content">
                            <div class="topic-content">
                                <p>A class is a blueprint or template for creating objects. An object is an instance of a class.</p>
                                
                                <h3>Class Syntax:</h3>
                                <div class="syntax-box">
                                    <code>class ClassName {<br>
                                    private:<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// private members<br>
                                    public:<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;// public members<br>
                                    };</code>
                                </div>

                                <div class="code-block">
                                    <div class="code-header">
                                        <span class="code-title">class_example.cpp</span>
                                        <button class="copy-btn" onclick="copyCode(this)">
                                            <i class="fas fa-copy"></i> Copy
                                        </button>
                                    </div>
                                    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

// Class definition
class Student {
private:
    string name;
    int age;
    double gpa;

public:
    // Constructor
    Student(string n, int a, double g) {
        name = n;
        age = a;
        gpa = g;
    }
    
    // Member functions (methods)
    void displayInfo() {
        cout &lt;&lt; "Name: " &lt;&lt; name &lt;&lt; endl;
        cout &lt;&lt; "Age: " &lt;&lt; age &lt;&lt; endl;
        cout &lt;&lt; "GPA: " &lt;&lt; gpa &lt;&lt; endl;
    }
    
    // Getter methods
    string getName() { return name; }
    int getAge() { return age; }
    double getGPA() { return gpa; }
    
    // Setter methods
    void setName(string n) { name = n; }
    void setAge(int a) { age = a; }
    void setGPA(double g) { gpa = g; }
    
    // Method to check if student is honor roll
    bool isHonorRoll() {
        return gpa >= 3.5;
    }
};

int main() {
    // Creating objects (instances of the class)
    Student student1("Alice Johnson", 20, 3.8);
    Student student2("Bob Smith", 19, 3.2);
    
    // Using object methods
    cout &lt;&lt; "Student 1 Information:" &lt;&lt; endl;
    student1.displayInfo();
    cout &lt;&lt; "Honor Roll: " &lt;&lt; (student1.isHonorRoll() ? "Yes" : "No") &lt;&lt; endl;
    cout &lt;&lt; endl;
    
    cout &lt;&lt; "Student 2 Information:" &lt;&lt; endl;
    student2.displayInfo();
    cout &lt;&lt; "Honor Roll: " &lt;&lt; (student2.isHonorRoll() ? "Yes" : "No") &lt;&lt; endl;
    
    // Modifying object data using setter methods
    student2.setGPA(3.7);
    cout &lt;&lt; "\nAfter GPA update:" &lt;&lt; endl;
    student2.displayInfo();
    
    return 0;
}</code></pre>
                                </div>

                                <h3>Key Concepts:</h3>
                                <ul>
                                    <li><strong>Class:</strong> A user-defined data type that serves as a blueprint</li>
                                    <li><strong>Object:</strong> An instance of a class with actual values</li>
                                    <li><strong>Member Variables:</strong> Data stored within the class</li>
                                    <li><strong>Member Functions:</strong> Functions that operate on the class data</li>
                                    <li><strong>Instantiation:</strong> The process of creating an object from a class</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </section>

                <!-- Constructors & Destructors -->
                <section class="content-section" id="constructors">
                    <div class="accordion-item">
                        <div class="accordion-header" >
                            <h2><i class="fas fa-hammer"></i> Constructors & Destructors</h2>
                            <i class="fas fa-chevron-down"></i>
                        </div>
                        <div class="accordion-content">
                            <div class="topic-content">
                                <p>Constructors are special methods called when an object is created. Destructors are called when an object is destroyed.</p>
                                
                                <h3>Types of Constructors:</h3>
                                <ul>
                                    <li><strong>Default Constructor:</strong> Takes no parameters</li>
                                    <li><strong>Parameterized Constructor:</strong> Takes parameters to initialize object</li>
                                    <li><strong>Copy Constructor:</strong> Creates a copy of another object</li>
                                </ul>

                                <div class="code-block">
                                    <div class="code-header">
                                        <span class="code-title">constructors_example.cpp</span>
                                        <button class="copy-btn" onclick="copyCode(this)">
                                            <i class="fas fa-copy"></i> Copy
                                        </button>
                                    </div>
                                    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

class Rectangle {
private:
    double length;
    double width;
    string color;

public:
    // Default constructor
    Rectangle() {
        length = 1.0;
        width = 1.0;
        color = "white";
        cout &lt;&lt; "Default constructor called" &lt;&lt; endl;
    }
    
    // Parameterized constructor
    Rectangle(double l, double w, string c) {
        length = l;
        width = w;
        color = c;
        cout &lt;&lt; "Parameterized constructor called" &lt;&lt; endl;
    }
    
    // Copy constructor
    Rectangle(const Rectangle &rect) {
        length = rect.length;
        width = rect.width;
        color = rect.color;
        cout &lt;&lt; "Copy constructor called" &lt;&lt; endl;
    }
    
    // Destructor
    ~Rectangle() {
        cout &lt;&lt; "Destructor called for " &lt;&lt; color &lt;&lt; " rectangle" &lt;&lt; endl;
    }
    
    // Member functions
    double getArea() {
        return length * width;
    }
    
    double getPerimeter() {
        return 2 * (length + width);
    }
    
    void displayInfo() {
        cout &lt;&lt; "Rectangle - Length: " &lt;&lt; length 
             &lt;&lt; ", Width: " &lt;&lt; width 
             &lt;&lt; ", Color: " &lt;&lt; color 
             &lt;&lt; ", Area: " &lt;&lt; getArea() &lt;&lt; endl;
    }
};

int main() {
    cout &lt;&lt; "Creating rectangle1 with default constructor:" &lt;&lt; endl;
    Rectangle rectangle1;  // Default constructor
    rectangle1.displayInfo();
    
    cout &lt;&lt; "\nCreating rectangle2 with parameterized constructor:" &lt;&lt; endl;
    Rectangle rectangle2(5.0, 3.0, "blue");  // Parameterized constructor
    rectangle2.displayInfo();
    
    cout &lt;&lt; "\nCreating rectangle3 with copy constructor:" &lt;&lt; endl;
    Rectangle rectangle3 = rectangle2;  // Copy constructor
    rectangle3.displayInfo();
    
    cout &lt;&lt; "\nProgram ending - destructors will be called:" &lt;&lt; endl;
    return 0;
}</code></pre>
                                </div>

                                <h3>Constructor Initialization List:</h3>
                                <p>A more efficient way to initialize member variables:</p>

                                <div class="code-block">
                                    <div class="code-header">
                                        <span class="code-title">initialization_list.cpp</span>
                                        <button class="copy-btn" onclick="copyCode(this)">
                                            <i class="fas fa-copy"></i> Copy
                                        </button>
                                    </div>
                                    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

class Person {
private:
    const int id;  // const member must be initialized
    string name;
    int age;

public:
    // Constructor with initialization list
    Person(int i, string n, int a) : id(i), name(n), age(a) {
        cout &lt;&lt; "Person created with ID: " &lt;&lt; id &lt;&lt; endl;
    }
    
    void displayInfo() {
        cout &lt;&lt; "ID: " &lt;&lt; id &lt;&lt; ", Name: " &lt;&lt; name &lt;&lt; ", Age: " &lt;&lt; age &lt;&lt; endl;
    }
};

int main() {
    Person person1(101, "John Doe", 25);
    person1.displayInfo();
    
    return 0;
}</code></pre>
                                </div>

                                <div class="info-box">
                                    <i class="fas fa-exclamation-triangle"></i>
                                    <p><strong>Important:</strong> Destructors are automatically called when objects go out of scope or are explicitly deleted. They're used for cleanup operations like freeing memory.</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </section>

                <!-- Access Modifiers -->
                <section class="content-section" id="access-modifiers">
                    <div class="accordion-item">
                        <div class="accordion-header" >
                            <h2><i class="fas fa-lock"></i> Access Modifiers</h2>
                            <i class="fas fa-chevron-down"></i>
                        </div>
                        <div class="accordion-content">
                            <div class="topic-content">
                                <p>Access modifiers control the visibility and accessibility of class members.</p>
                                
                                <div class="access-modifiers-grid">
                                    <div class="access-modifier-card">
                                        <h4><i class="fas fa-lock"></i> Private</h4>
                                        <p>Members are accessible only within the same class</p>
                                        <ul>
                                            <li>Default access level for class members</li>
                                            <li>Provides data hiding</li>
                                            <li>Accessed through public methods</li>
                                        </ul>
                                    </div>
                                    <div class="access-modifier-card">
                                        <h4><i class="fas fa-unlock"></i> Public</h4>
                                        <p>Members are accessible from anywhere</p>
                                        <ul>
                                            <li>Can be accessed by any code</li>
                                            <li>Forms the interface of the class</li>
                                            <li>Should be used carefully</li>
                                        </ul>
                                    </div>
                                    <div class="access-modifier-card">
                                        <h4><i class="fas fa-shield-alt"></i> Protected</h4>
                                        <p>Members are accessible within the class and its derived classes</p>
                                        <ul>
                                            <li>Used in inheritance</li>
                                            <li>More restrictive than public</li>
                                            <li>Less restrictive than private</li>
                                        </ul>
                                    </div>
                                </div>

                                <div class="code-block">
                                    <div class="code-header">
                                        <span class="code-title">access_modifiers_example.cpp</span>
                                        <button class="copy-btn" onclick="copyCode(this)">
                                            <i class="fas fa-copy"></i> Copy
                                        </button>
                                    </div>
                                    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

class BankAccount {
private:
    double balance;        // Private - can't be accessed directly
    string accountNumber;  // Private - sensitive information
    
protected:
    string bankName;       // Protected - accessible to derived classes
    
public:
    string ownerName;      // Public - can be accessed directly
    
    // Constructor
    BankAccount(string owner, string accNum, double initialBalance) {
        ownerName = owner;
        accountNumber = accNum;
        balance = initialBalance;
        bankName = "Global Bank";
    }
    
    // Public methods to access private members
    double getBalance() {
        return balance;
    }
    
    string getAccountNumber() {
        return accountNumber;
    }
    
    void deposit(double amount) {
        if (amount > 0) {
            balance += amount;
            cout &lt;&lt; "Deposited $" &lt;&lt; amount &lt;&lt; ". New balance: $" &lt;&lt; balance &lt;&lt; endl;
        }
    }
    
    bool withdraw(double amount) {
        if (amount > 0 && amount &lt;= balance) {
            balance -= amount;
            cout &lt;&lt; "Withdrew $" &lt;&lt; amount &lt;&lt; ". New balance: $" &lt;&lt; balance &lt;&lt; endl;
            return true;
        } else {
            cout &lt;&lt; "Invalid withdrawal amount or insufficient funds!" &lt;&lt; endl;
            return false;
        }
    }
    
    void displayAccountInfo() {
        cout &lt;&lt; "Account Owner: " &lt;&lt; ownerName &lt;&lt; endl;
        cout &lt;&lt; "Account Number: " &lt;&lt; accountNumber &lt;&lt; endl;
        cout &lt;&lt; "Bank: " &lt;&lt; bankName &lt;&lt; endl;
        cout &lt;&lt; "Balance: $" &lt;&lt; balance &lt;&lt; endl;
    }
};

// Derived class to demonstrate protected access
class SavingsAccount : public BankAccount {
private:
    double interestRate;
    
public:
    SavingsAccount(string owner, string accNum, double initialBalance, double rate) 
        : BankAccount(owner, accNum, initialBalance) {
        interestRate = rate;
    }
    
    void addInterest() {
        double interest = getBalance() * interestRate / 100;
        deposit(interest);
        cout &lt;&lt; "Interest added: $" &lt;&lt; interest &lt;&lt; endl;
    }
    
    void displayBankInfo() {
        // Can access protected member from base class
        cout &lt;&lt; "This account is with: " &lt;&lt; bankName &lt;&lt; endl;
    }
};

int main() {
    BankAccount account1("John Smith", "ACC001", 1000.0);
    
    // Accessing public members
    cout &lt;&lt; "Account owner: " &lt;&lt; account1.ownerName &lt;&lt; endl;
    
    // Accessing private members through public methods
    cout &lt;&lt; "Balance: $" &lt;&lt; account1.getBalance() &lt;&lt; endl;
    
    // Using public methods
    account1.deposit(500.0);
    account1.withdraw(200.0);
    account1.displayAccountInfo();
    
    cout &lt;&lt; "\n--- Savings Account ---" &lt;&lt; endl;
    SavingsAccount savings("Jane Doe", "SAV001", 2000.0, 2.5);
    savings.displayAccountInfo();
    savings.addInterest();
    savings.displayBankInfo();  // Accessing protected member through derived class
    
    // The following would cause compilation errors:
    // cout &lt;&lt; account1.balance;        // Error: private member
    // cout &lt;&lt; account1.accountNumber;  // Error: private member
    // cout &lt;&lt; account1.bankName;       // Error: protected member (not accessible here)
    
    return 0;
}</code></pre>
                                </div>

                                <div class="info-box">
                                    <i class="fas fa-lightbulb"></i>
                                    <p><strong>Best Practice:</strong> Keep data members private and provide public methods (getters/setters) to access them. This ensures data integrity and encapsulation.</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </section>

                <!-- Inheritance -->
                <section class="content-section" id="inheritance">
                    <div class="accordion-item">
                        <div class="accordion-header" >
                            <h2><i class="fas fa-sitemap"></i> Inheritance</h2>
                            <i class="fas fa-chevron-down"></i>
                        </div>
                        <div class="accordion-content">
                            <div class="topic-content">
                                <p>Inheritance allows a class to inherit properties and methods from another class, promoting code reusability.</p>
                                
                                <h3>Types of Inheritance:</h3>
                                <div class="inheritance-types">
                                    <div class="inheritance-type">
                                        <h4>Single Inheritance</h4>
                                        <p>One derived class inherits from one base class</p>
                                    </div>
                                    <div class="inheritance-type">
                                        <h4>Multiple Inheritance</h4>
                                        <p>One derived class inherits from multiple base classes</p>
                                    </div>
                                    <div class="inheritance-type">
                                        <h4>Multilevel Inheritance</h4>
                                        <p>A derived class becomes base class for another class</p>
                                    </div>
                                    <div class="inheritance-type">
                                        <h4>Hierarchical Inheritance</h4>
                                        <p>Multiple derived classes inherit from one base class</p>
                                    </div>
                                </div>

                                <div class="code-block">
                                    <div class="code-header">
                                        <span class="code-title">inheritance_example.cpp</span>
                                        <button class="copy-btn" onclick="copyCode(this)">
                                            <i class="fas fa-copy"></i> Copy
                                        </button>
                                    </div>
                                    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

// Base class (Parent class)
class Vehicle {
protected:
    string brand;
    string model;
    int year;
    
public:
    Vehicle(string b, string m, int y) : brand(b), model(m), year(y) {
        cout &lt;&lt; "Vehicle constructor called" &lt;&lt; endl;
    }
    
    void displayBasicInfo() {
        cout &lt;&lt; "Brand: " &lt;&lt; brand &lt;&lt; endl;
        cout &lt;&lt; "Model: " &lt;&lt; model &lt;&lt; endl;
        cout &lt;&lt; "Year: " &lt;&lt; year &lt;&lt; endl;
    }
    
    virtual void start() {  // Virtual function for polymorphism
        cout &lt;&lt; "Vehicle is starting..." &lt;&lt; endl;
    }
    
    virtual ~Vehicle() {  // Virtual destructor
        cout &lt;&lt; "Vehicle destructor called" &lt;&lt; endl;
    }
};

// Derived class (Child class) - Single Inheritance
class Car : public Vehicle {
private:
    int doors;
    string fuelType;
    
public:
    Car(string b, string m, int y, int d, string fuel) 
        : Vehicle(b, m, y), doors(d), fuelType(fuel) {
        cout &lt;&lt; "Car constructor called" &lt;&lt; endl;
    }
    
    void displayCarInfo() {
        displayBasicInfo();  // Inherited method
        cout &lt;&lt; "Doors: " &lt;&lt; doors &lt;&lt; endl;
        cout &lt;&lt; "Fuel Type: " &lt;&lt; fuelType &lt;&lt; endl;
    }
    
    void start() override {  // Override base class method
        cout &lt;&lt; "Car engine is starting with a key..." &lt;&lt; endl;
    }
    
    void honk() {  // Car-specific method
        cout &lt;&lt; "Beep beep!" &lt;&lt; endl;
    }
    
    ~Car() {
        cout &lt;&lt; "Car destructor called" &lt;&lt; endl;
    }
};

// Another derived class - Single Inheritance
class Motorcycle : public Vehicle {
private:
    bool hasSidecar;
    
public:
    Motorcycle(string b, string m, int y, bool sidecar) 
        : Vehicle(b, m, y), hasSidecar(sidecar) {
        cout &lt;&lt; "Motorcycle constructor called" &lt;&lt; endl;
    }
    
    void displayMotorcycleInfo() {
        displayBasicInfo();
        cout &lt;&lt; "Has Sidecar: " &lt;&lt; (hasSidecar ? "Yes" : "No") &lt;&lt; endl;
    }
    
    void start() override {
        cout &lt;&lt; "Motorcycle is kick-starting..." &lt;&lt; endl;
    }
    
    void wheelie() {
        cout &lt;&lt; "Performing a wheelie!" &lt;&lt; endl;
    }
    
    ~Motorcycle() {
        cout &lt;&lt; "Motorcycle destructor called" &lt;&lt; endl;
    }
};

// Multilevel Inheritance - SportsCar inherits from Car
class SportsCar : public Car {
private:
    int topSpeed;
    bool hasTurbo;
    
public:
    SportsCar(string b, string m, int y, int d, string fuel, int speed, bool turbo)
        : Car(b, m, y, d, fuel), topSpeed(speed), hasTurbo(turbo) {
        cout &lt;&lt; "SportsCar constructor called" &lt;&lt; endl;
    }
    
    void displaySportsCarInfo() {
        displayCarInfo();  // Inherited from Car
        cout &lt;&lt; "Top Speed: " &lt;&lt; topSpeed &lt;&lt; " mph" &lt;&lt; endl;
        cout &lt;&lt; "Has Turbo: " &lt;&lt; (hasTurbo ? "Yes" : "No") &lt;&lt; endl;
    }
    
    void start() override {
        cout &lt;&lt; "Sports car engine roaring to life!" &lt;&lt; endl;
    }
    
    void activateTurbo() {
        if (hasTurbo) {
            cout &lt;&lt; "Turbo activated! Maximum power!" &lt;&lt; endl;
        } else {
            cout &lt;&lt; "No turbo available." &lt;&lt; endl;
        }
    }
    
    ~SportsCar() {
        cout &lt;&lt; "SportsCar destructor called" &lt;&lt; endl;
    }
};

int main() {
    cout &lt;&lt; "=== Creating a Car ===" &lt;&lt; endl;
    Car myCar("Toyota", "Camry", 2022, 4, "Gasoline");
    myCar.displayCarInfo();
    myCar.start();
    myCar.honk();
    
    cout &lt;&lt; "\n=== Creating a Motorcycle ===" &lt;&lt; endl;
    Motorcycle myBike("Harley-Davidson", "Street 750", 2021, false);
    myBike.displayMotorcycleInfo();
    myBike.start();
    myBike.wheelie();
    
    cout &lt;&lt; "\n=== Creating a Sports Car ===" &lt;&lt; endl;
    SportsCar mySportsCar("Ferrari", "488 GTB", 2023, 2, "Gasoline", 205, true);
    mySportsCar.displaySportsCarInfo();
    mySportsCar.start();
    mySportsCar.activateTurbo();
    
    cout &lt;&lt; "\n=== Program ending - destructors will be called ===" &lt;&lt; endl;
    return 0;
}</code></pre>
                                </div>

                                <h3>Access Specifiers in Inheritance:</h3>
                                <div class="inheritance-access">
                                    <div class="access-table">
                                        <table>
                                            <thead>
                                                <tr>
                                                    <th>Base Class</th>
                                                    <th>Public Inheritance</th>
                                                    <th>Protected Inheritance</th>
                                                    <th>Private Inheritance</th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                <tr>
                                                    <td>Public</td>
                                                    <td>Public</td>
                                                    <td>Protected</td>
                                                    <td>Private</td>
                                                </tr>
                                                <tr>
                                                    <td>Protected</td>
                                                    <td>Protected</td>
                                                    <td>Protected</td>
                                                    <td>Private</td>
                                                </tr>
                                                <tr>
                                                    <td>Private</td>
                                                    <td>Not Accessible</td>
                                                    <td>Not Accessible</td>
                                                    <td>Not Accessible</td>
                                                </tr>
                                            </tbody>
                                        </table>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </section>

                <!-- Polymorphism -->
                <section class="content-section" id="polymorphism">
                    <div class="accordion-item">
                        <div class="accordion-header" >
                            <h2><i class="fas fa-shapes"></i> Polymorphism</h2>
                            <i class="fas fa-chevron-down"></i>
                        </div>
                        <div class="accordion-content">
                            <div class="topic-content">
                                <p>Polymorphism allows objects of different types to be treated as objects of a common base type, with the ability to call the appropriate method based on the actual object type.</p>
                                
                                <h3>Types of Polymorphism:</h3>
                                <div class="polymorphism-types">
                                    <div class="polymorphism-type">
                                        <h4>Compile-time Polymorphism</h4>
                                        <ul>
                                            <li>Function Overloading</li>
                                            <li>Operator Overloading</li>
                                        </ul>
                                    </div>
                                    <div class="polymorphism-type">
                                        <h4>Runtime Polymorphism</h4>
                                        <ul>
                                            <li>Virtual Functions</li>
                                            <li>Function Overriding</li>
                                        </ul>
                                    </div>
                                </div>

                                <div class="code-block">
                                    <div class="code-header">
                                        <span class="code-title">polymorphism_example.cpp</span>
                                        <button class="copy-btn" onclick="copyCode(this)">
                                            <i class="fas fa-copy"></i> Copy
                                        </button>
                                    </div>
                                    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;memory&gt;
using namespace std;

// Base class with virtual functions
class Shape {
protected:
    string color;
    
public:
    Shape(string c) : color(c) {}
    
    // Pure virtual function makes this an abstract class
    virtual double getArea() = 0;
    virtual double getPerimeter() = 0;
    
    // Virtual function with default implementation
    virtual void display() {
        cout &lt;&lt; "This is a " &lt;&lt; color &lt;&lt; " shape" &lt;&lt; endl;
    }
    
    // Virtual destructor
    virtual ~Shape() {
        cout &lt;&lt; "Shape destructor called" &lt;&lt; endl;
    }
};

// Derived class - Circle
class Circle : public Shape {
private:
    double radius;
    
public:
    Circle(string c, double r) : Shape(c), radius(r) {}
    
    double getArea() override {
        return 3.14159 * radius * radius;
    }
    
    double getPerimeter() override {
        return 2 * 3.14159 * radius;
    }
    
    void display() override {
        cout &lt;&lt; "Circle with radius " &lt;&lt; radius &lt;&lt; " and color " &lt;&lt; color &lt;&lt; endl;
    }
    
    ~Circle() {
        cout &lt;&lt; "Circle destructor called" &lt;&lt; endl;
    }
};

// Derived class - Rectangle
class Rectangle : public Shape {
private:
    double length, width;
    
public:
    Rectangle(string c, double l, double w) : Shape(c), length(l), width(w) {}
    
    double getArea() override {
        return length * width;
    }
    
    double getPerimeter() override {
        return 2 * (length + width);
    }
    
    void display() override {
        cout &lt;&lt; "Rectangle " &lt;&lt; length &lt;&lt; "x" &lt;&lt; width &lt;&lt; " with color " &lt;&lt; color &lt;&lt; endl;
    }
    
    ~Rectangle() {
        cout &lt;&lt; "Rectangle destructor called" &lt;&lt; endl;
    }
};

// Derived class - Triangle
class Triangle : public Shape {
private:
    double side1, side2, side3;
    
public:
    Triangle(string c, double s1, double s2, double s3) 
        : Shape(c), side1(s1), side2(s2), side3(s3) {}
    
    double getArea() override {
        // Using Heron's formula
        double s = (side1 + side2 + side3) / 2;
        return sqrt(s * (s - side1) * (s - side2) * (s - side3));
    }
    
    double getPerimeter() override {
        return side1 + side2 + side3;
    }
    
    void display() override {
        cout &lt;&lt; "Triangle with sides " &lt;&lt; side1 &lt;&lt; ", " &lt;&lt; side2 
             &lt;&lt; ", " &lt;&lt; side3 &lt;&lt; " and color " &lt;&lt; color &lt;&lt; endl;
    }
    
    ~Triangle() {
        cout &lt;&lt; "Triangle destructor called" &lt;&lt; endl;
    }
};

// Function demonstrating polymorphism
void printShapeInfo(Shape* shape) {
    shape-&gt;display();
    cout &lt;&lt; "Area: " &lt;&lt; shape-&gt;getArea() &lt;&lt; endl;
    cout &lt;&lt; "Perimeter: " &lt;&lt; shape-&gt;getPerimeter() &lt;&lt; endl;
    cout &lt;&lt; "------------------------" &lt;&lt; endl;
}

// Function overloading example (compile-time polymorphism)
class Calculator {
public:
    int add(int a, int b) {
        return a + b;
    }
    
    double add(double a, double b) {
        return a + b;
    }
    
    int add(int a, int b, int c) {
        return a + b + c;
    }
    
    string add(string a, string b) {
        return a + b;
    }
};

int main() {
    cout &lt;&lt; "=== Runtime Polymorphism Example ===" &lt;&lt; endl;
    
    // Create objects using smart pointers
    vector&lt;unique_ptr&lt;Shape&gt;&gt; shapes;
    shapes.push_back(make_unique&lt;Circle&gt;("red", 5.0));
    shapes.push_back(make_unique&lt;Rectangle&gt;("blue", 4.0, 6.0));
    shapes.push_back(make_unique&lt;Triangle&gt;("green", 3.0, 4.0, 5.0));
    
    // Polymorphic behavior - same interface, different implementations
    for (auto& shape : shapes) {
        printShapeInfo(shape.get());
    }
    
    cout &lt;&lt; "\n=== Compile-time Polymorphism (Function Overloading) ===" &lt;&lt; endl;
    Calculator calc;
    
    cout &lt;&lt; "add(5, 3) = " &lt;&lt; calc.add(5, 3) &lt;&lt; endl;
    cout &lt;&lt; "add(5.5, 3.2) = " &lt;&lt; calc.add(5.5, 3.2) &lt;&lt; endl;
    cout &lt;&lt; "add(1, 2, 3) = " &lt;&lt; calc.add(1, 2, 3) &lt;&lt; endl;
    cout &lt;&lt; "add(\"Hello\", \" World\") = " &lt;&lt; calc.add(string("Hello"), string(" World")) &lt;&lt; endl;
    
    return 0;
}</code></pre>
                                </div>

                                <div class="info-box">
                                    <i class="fas fa-lightbulb"></i>
                                    <p><strong>Key Point:</strong> Virtual functions enable runtime polymorphism, allowing the correct function to be called based on the actual object type, not the pointer type.</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </section>

                <!-- Encapsulation -->
                <section class="content-section" id="encapsulation">
                    <div class="accordion-item">
                        <div class="accordion-header">
                            <h2><i class="fas fa-box"></i> Encapsulation</h2>
                            <i class="fas fa-chevron-down"></i>
                        </div>
                        <div class="accordion-content">
                            <div class="topic-content">
                                <p>Encapsulation is the bundling of data and methods that operate on that data within a single unit, while restricting direct access to some of the object's components.</p>
                                
                                <h3>Benefits of Encapsulation:</h3>
                                <ul>
                                    <li><strong>Data Hiding:</strong> Internal representation is hidden from outside</li>
                                    <li><strong>Increased Security:</strong> Prevents unauthorized access to data</li>
                                    <li><strong>Easy Maintenance:</strong> Code changes don't affect other parts</li>
                                    <li><strong>Flexibility:</strong> Can change implementation without affecting users</li>
                                </ul>

                                <div class="code-block">
                                    <div class="code-header">
                                        <span class="code-title">encapsulation_example.cpp</span>
                                        <button class="copy-btn" onclick="copyCode(this)">
                                            <i class="fas fa-copy"></i> Copy
                                        </button>
                                    </div>
                                    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

class Employee {
private:
    // Encapsulated data members
    int employeeId;
    string name;
    double salary;
    string department;
    bool isActive;

public:
    // Constructor
    Employee(int id, string empName, double sal, string dept) {
        employeeId = id;
        name = empName;
        salary = sal;
        department = dept;
        isActive = true;
    }
    
    // Public methods to access private data (Getters)
    int getEmployeeId() const { return employeeId; }
    string getName() const { return name; }
    double getSalary() const { return salary; }
    string getDepartment() const { return department; }
    bool getActiveStatus() const { return isActive; }
    
    // Public methods to modify private data (Setters) with validation
    void setName(const string& empName) {
        if (!empName.empty()) {
            name = empName;
        } else {
            cout << "Error: Name cannot be empty!" << endl;
        }
    }
    
    void setSalary(double sal) {
        if (sal >= 0) {
            salary = sal;
        } else {
            cout << "Error: Salary cannot be negative!" << endl;
        }
    }
    
    void setDepartment(const string& dept) {
        if (!dept.empty()) {
            department = dept;
        } else {
            cout << "Error: Department cannot be empty!" << endl;
        }
    }
    
    // Method to deactivate employee
    void deactivateEmployee() {
        isActive = false;
        cout << "Employee " << name << " has been deactivated." << endl;
    }
    
    // Method to give raise with business logic
    void giveRaise(double percentage) {
        if (percentage > 0 && percentage <= 50) {
            double oldSalary = salary;
            salary += salary * (percentage / 100);
            cout << name << "'s salary increased from $" << oldSalary 
                 << " to $" << salary << " (" << percentage << "% raise)" << endl;
        } else {
            cout << "Error: Invalid raise percentage!" << endl;
        }
    }
    
    // Method to display employee information
    void displayEmployeeInfo() const {
        cout << "Employee ID: " << employeeId << endl;
        cout << "Name: " << name << endl;
        cout << "Department: " << department << endl;
        cout << "Salary: $" << salary << endl;
        cout << "Status: " << (isActive ? "Active" : "Inactive") << endl;
        cout << "------------------------" << endl;
    }
};

// Demonstration of encapsulation
int main() {
    cout << "=== Encapsulation Example ===" << endl;
    
    Employee emp1(101, "John Smith", 50000, "Engineering");
    Employee emp2(102, "Jane Doe", 55000, "Marketing");
    
    // Display initial information
    cout << "Initial Employee Information:" << endl;
    emp1.displayEmployeeInfo();
    emp2.displayEmployeeInfo();
    
    // Using public methods to access and modify data
    cout << "Accessing data through public methods:" << endl;
    cout << "Employee 1 Name: " << emp1.getName() << endl;
    cout << "Employee 1 Salary: $" << emp1.getSalary() << endl;
    
    // Modifying data through setters (with validation)
    cout << "\nModifying employee data:" << endl;
    emp1.giveRaise(10);  // 10% raise
    emp2.setDepartment("Sales");
    
    // Trying to set invalid data (validation in action)
    cout << "\nTrying to set invalid data:" << endl;
    emp1.setSalary(-1000);  // This should show an error
    emp2.setName("");       // This should show an error
    
    // Final state
    cout << "\nFinal Employee Information:" << endl;
    emp1.displayEmployeeInfo();
    emp2.displayEmployeeInfo();
    
    // The following would cause compilation errors (encapsulation in action):
    // emp1.salary = 100000;        // Error: private member
    // emp1.employeeId = 999;       // Error: private member
    // cout << emp1.isActive;       // Error: private member
    
    return 0;
}</code></pre>
                                </div>

                                <div class="info-box">
                                    <i class="fas fa-shield-alt"></i>
                                    <p><strong>Best Practice:</strong> Always keep data members private and provide controlled access through public methods. This ensures data integrity and allows for validation.</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </section>

                <!-- Abstraction -->
                <section class="content-section" id="abstraction">
                    <div class="accordion-item">
                        <div class="accordion-header">
                            <h2><i class="fas fa-eye-slash"></i> Abstraction</h2>
                            <i class="fas fa-chevron-down"></i>
                        </div>
                        <div class="accordion-content">
                            <div class="topic-content">
                                <p>Abstraction is the process of hiding complex implementation details while showing only the essential features of an object. It focuses on what an object does rather than how it does it.</p>
                                
                                <h3>Types of Abstraction:</h3>
                                <div class="abstraction-types">
                                    <div class="abstraction-type">
                                        <h4>Data Abstraction</h4>
                                        <p>Hiding the internal representation of data</p>
                                    </div>
                                    <div class="abstraction-type">
                                        <h4>Control Abstraction</h4>
                                        <p>Hiding the implementation details of functions</p>
                                    </div>
                                </div>

                                <div class="code-block">
                                    <div class="code-header">
                                        <span class="code-title">abstraction_example.cpp</span>
                                        <button class="copy-btn" onclick="copyCode(this)">
                                            <i class="fas fa-copy"></i> Copy
                                        </button>
                                    </div>
                                    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
using namespace std;

// Abstract base class (interface)
class DatabaseConnection {
public:
    // Pure virtual functions (abstract methods)
    virtual bool connect(const string& connectionString) = 0;
    virtual bool disconnect() = 0;
    virtual bool executeQuery(const string& query) = 0;
    virtual vector&lt;string&gt; fetchResults() = 0;
    
    // Virtual destructor
    virtual ~DatabaseConnection() = default;
    
    // Common method with implementation
    void showConnectionStatus() {
        cout << "Database connection status checked." << endl;
    }
};

// Concrete implementation for MySQL
class MySQLConnection : public DatabaseConnection {
private:
    bool isConnected;
    string serverAddress;
    vector&lt;string&gt; queryResults;
    
    // Private helper method (hidden implementation detail)
    bool validateConnectionString(const string& connStr) {
        return !connStr.empty() && connStr.find("mysql://") == 0;
    }

public:
    MySQLConnection() : isConnected(false) {}
    
    bool connect(const string& connectionString) override {
        if (validateConnectionString(connectionString)) {
            serverAddress = connectionString;
            isConnected = true;
            cout << "Connected to MySQL database: " << serverAddress << endl;
            return true;
        }
        cout << "Failed to connect to MySQL database!" << endl;
        return false;
    }
    
    bool disconnect() override {
        if (isConnected) {
            isConnected = false;
            cout << "Disconnected from MySQL database." << endl;
            return true;
        }
        return false;
    }
    
    bool executeQuery(const string& query) override {
        if (!isConnected) {
            cout << "Error: Not connected to database!" << endl;
            return false;
        }
        
        cout << "Executing MySQL query: " << query << endl;
        
        // Simulate query execution and results
        queryResults.clear();
        queryResults.push_back("Result 1: MySQL data");
        queryResults.push_back("Result 2: MySQL data");
        
        return true;
    }
    
    vector&lt;string&gt; fetchResults() override {
        return queryResults;
    }
};

// Concrete implementation for PostgreSQL
class PostgreSQLConnection : public DatabaseConnection {
private:
    bool isConnected;
    string serverAddress;
    vector&lt;string&gt; queryResults;
    
    // Private helper method (different implementation)
    bool establishConnection(const string& connStr) {
        // PostgreSQL-specific connection logic
        return !connStr.empty() && connStr.find("postgresql://") == 0;
    }

public:
    PostgreSQLConnection() : isConnected(false) {}
    
    bool connect(const string& connectionString) override {
        if (establishConnection(connectionString)) {
            serverAddress = connectionString;
            isConnected = true;
            cout << "Connected to PostgreSQL database: " << serverAddress << endl;
            return true;
        }
        cout << "Failed to connect to PostgreSQL database!" << endl;
        return false;
    }
    
    bool disconnect() override {
        if (isConnected) {
            isConnected = false;
            cout << "Disconnected from PostgreSQL database." << endl;
            return true;
        }
        return false;
    }
    
    bool executeQuery(const string& query) override {
        if (!isConnected) {
            cout << "Error: Not connected to database!" << endl;
            return false;
        }
        
        cout << "Executing PostgreSQL query: " << query << endl;
        
        // Simulate query execution and results
        queryResults.clear();
        queryResults.push_back("Result 1: PostgreSQL data");
        queryResults.push_back("Result 2: PostgreSQL data");
        
        return true;
    }
    
    vector&lt;string&gt; fetchResults() override {
        return queryResults;
    }
};

// High-level database manager (uses abstraction)
class DatabaseManager {
private:
    DatabaseConnection* dbConnection;

public:
    DatabaseManager(DatabaseConnection* connection) : dbConnection(connection) {}
    
    void performDatabaseOperations(const string& connectionString) {
        // Client code doesn't need to know implementation details
        if (dbConnection->connect(connectionString)) {
            dbConnection->showConnectionStatus();
            
            // Execute a query
            if (dbConnection->executeQuery("SELECT * FROM users")) {
                vector&lt;string&gt; results = dbConnection->fetchResults();
                cout << "Query results:" << endl;
                for (const auto& result : results) {
                    cout << "- " << result << endl;
                }
            }
            
            dbConnection->disconnect();
        }
    }
    
    ~DatabaseManager() {
        delete dbConnection;
    }
};

int main() {
    cout << "=== Abstraction Example ===" << endl;
    
    // Using MySQL implementation
    cout << "\n--- Using MySQL Database ---" << endl;
    DatabaseManager mysqlManager(new MySQLConnection());
    mysqlManager.performDatabaseOperations("mysql://localhost:3306/mydb");
    
    // Using PostgreSQL implementation
    cout << "\n--- Using PostgreSQL Database ---" << endl;
    DatabaseManager postgresManager(new PostgreSQLConnection());
    postgresManager.performDatabaseOperations("postgresql://localhost:5432/mydb");
    
    // The client code (DatabaseManager) doesn't need to know
    // the specific implementation details of MySQL or PostgreSQL
    // It just works with the abstract interface
    
    return 0;
}</code></pre>
                                </div>

                                <h3>Abstract Classes vs Interfaces:</h3>
                                <div class="comparison-table">
                                    <table>
                                        <thead>
                                            <tr>
                                                <th>Abstract Class</th>
                                                <th>Interface (Pure Abstract Class)</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            <tr>
                                                <td>Can have both abstract and concrete methods</td>
                                                <td>All methods are pure virtual (abstract)</td>
                                            </tr>
                                            <tr>
                                                <td>Can have member variables</td>
                                                <td>Usually no member variables</td>
                                            </tr>
                                            <tr>
                                                <td>Can have constructors</td>
                                                <td>Usually no constructors</td>
                                            </tr>
                                            <tr>
                                                <td>Supports single inheritance in C++</td>
                                                <td>Can simulate multiple inheritance</td>
                                            </tr>
                                        </tbody>
                                    </table>
                                </div>

                                <div class="info-box">
                                    <i class="fas fa-lightbulb"></i>
                                    <p><strong>Remember:</strong> Abstraction helps in reducing complexity by hiding unnecessary details and showing only the relevant features to the user.</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </section>

                <!-- Virtual Functions -->
                <section class="content-section" id="virtual-functions">
                    <div class="accordion-item">
                        <div class="accordion-header">
                            <h2><i class="fas fa-code-branch"></i> Virtual Functions</h2>
                            <i class="fas fa-chevron-down"></i>
                        </div>
                        <div class="accordion-content">
                            <div class="topic-content">
                                <p>Virtual functions enable runtime polymorphism in C++. They allow a program to call the appropriate function based on the actual type of the object, not the type of the pointer or reference.</p>
                                
                                <h3>Types of Virtual Functions:</h3>
                                <ul>
                                    <li><strong>Virtual Function:</strong> Can be overridden in derived classes</li>
                                    <li><strong>Pure Virtual Function:</strong> Must be overridden in derived classes</li>
                                    <li><strong>Virtual Destructor:</strong> Ensures proper cleanup in inheritance hierarchies</li>
                                </ul>

                                <div class="code-block">
                                    <div class="code-header">
                                        <span class="code-title">virtual_functions_example.cpp</span>
                                        <button class="copy-btn" onclick="copyCode(this)">
                                            <i class="fas fa-copy"></i> Copy
                                        </button>
                                    </div>
                                    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;memory&gt;
using namespace std;

// Base class with virtual functions
class Animal {
protected:
    string name;
    int age;

public:
    Animal(const string& animalName, int animalAge) : name(animalName), age(animalAge) {
        cout << "Animal constructor: " << name << endl;
    }
    
    // Virtual function - can be overridden
    virtual void makeSound() {
        cout << name << " makes a generic animal sound." << endl;
    }
    
    // Virtual function with default implementation
    virtual void move() {
        cout << name << " moves around." << endl;
    }
    
    // Pure virtual function - must be overridden
    virtual void eat() = 0;
    
    // Virtual function for displaying information
    virtual void displayInfo() {
        cout << "Name: " << name << ", Age: " << age << " years" << endl;
    }
    
    // Virtual destructor - important for proper cleanup
    virtual ~Animal() {
        cout << "Animal destructor: " << name << endl;
    }
};

class Dog : public Animal {
private:
    string breed;

public:
    Dog(const string& dogName, int dogAge, const string& dogBreed) 
        : Animal(dogName, dogAge), breed(dogBreed) {
        cout << "Dog constructor: " << name << endl;
    }
    
    // Override virtual function
    void makeSound() override {
        cout << name << " barks: Woof! Woof!" << endl;
    }
    
    // Override virtual function
    void move() override {
        cout << name << " runs around wagging its tail." << endl;
    }
    
    // Implement pure virtual function
    void eat() override {
        cout << name << " eats dog food and treats." << endl;
    }
    
    // Override and extend displayInfo
    void displayInfo() override {
        Animal::displayInfo();  // Call base class version
        cout << "Breed: " << breed << endl;
    }
    
    // Dog-specific method
    void fetch() {
        cout << name << " fetches the ball!" << endl;
    }
    
    ~Dog() {
        cout << "Dog destructor: " << name << endl;
    }
};

class Cat : public Animal {
private:
    bool isIndoor;

public:
    Cat(const string& catName, int catAge, bool indoor) 
        : Animal(catName, catAge), isIndoor(indoor) {
        cout << "Cat constructor: " << name << endl;
    }
    
    // Override virtual function
    void makeSound() override {
        cout << name << " meows: Meow! Meow!" << endl;
    }
    
    // Override virtual function
    void move() override {
        cout << name << " gracefully jumps and climbs." << endl;
    }
    
    // Implement pure virtual function
    void eat() override {
        cout << name << " eats cat food and fish." << endl;
    }
    
    // Override and extend displayInfo
    void displayInfo() override {
        Animal::displayInfo();
        cout << "Indoor cat: " << (isIndoor ? "Yes" : "No") << endl;
    }
    
    // Cat-specific method
    void purr() {
        cout << name << " purrs contentedly." << endl;
    }
    
    ~Cat() {
        cout << "Cat destructor: " << name << endl;
    }
};

class Bird : public Animal {
private:
    bool canFly;

public:
    Bird(const string& birdName, int birdAge, bool flying) 
        : Animal(birdName, birdAge), canFly(flying) {
        cout << "Bird constructor: " << name << endl;
    }
    
    // Override virtual function
    void makeSound() override {
        cout << name << " chirps: Tweet! Tweet!" << endl;
    }
    
    // Override virtual function
    void move() override {
        if (canFly) {
            cout << name << " flies through the sky." << endl;
        } else {
            cout << name << " hops around on the ground." << endl;
        }
    }
    
    // Implement pure virtual function
    void eat() override {
        cout << name << " eats seeds and insects." << endl;
    }
    
    // Override and extend displayInfo
    void displayInfo() override {
        Animal::displayInfo();
        cout << "Can fly: " << (canFly ? "Yes" : "No") << endl;
    }
    
    // Bird-specific method
    void buildNest() {
        cout << name << " builds a cozy nest." << endl;
    }
    
    ~Bird() {
        cout << "Bird destructor: " << name << endl;
    }
};

// Function demonstrating polymorphism with virtual functions
void animalActions(Animal* animal) {
    cout << "\n--- Animal Actions ---" << endl;
    animal->displayInfo();
    animal->makeSound();
    animal->move();
    animal->eat();
    cout << "----------------------" << endl;
}

// Demonstrating virtual function table (vtable) concept
void demonstrateVirtualFunctions() {
    cout << "\n=== Virtual Functions Demonstration ===" << endl;
    
    // Create animals using base class pointers
    vector<unique_ptr<Animal>> animals;
    animals.push_back(make_unique<Dog>("Buddy", 3, "Golden Retriever"));
    animals.push_back(make_unique<Cat>("Whiskers", 2, true));
    animals.push_back(make_unique<Bird>("Robin", 1, true));
    
    // Polymorphic behavior - calls the appropriate derived class methods
    for (auto& animal : animals) {
        animalActions(animal.get());
    }
}

// Function without virtual functions (static binding)
class NonVirtualBase {
public:
    void show() {
        cout << "NonVirtualBase::show()" << endl;
    }
};

class NonVirtualDerived : public NonVirtualBase {
public:
    void show() {
        cout << "NonVirtualDerived::show()" << endl;
    }
};

void demonstrateNonVirtual() {
    cout << "\n=== Non-Virtual Functions (Static Binding) ===" << endl;
    
    NonVirtualBase* ptr = new NonVirtualDerived();
    ptr->show();  // Calls NonVirtualBase::show() - not what we might expect!
    
    delete ptr;
}

int main() {
    cout << "=== Virtual Functions Example ===" << endl;
    
    // Demonstrate virtual functions
    demonstrateVirtualFunctions();
    
    // Show the difference with non-virtual functions
    demonstrateNonVirtual();
    
    cout << "\n=== Program ending - destructors will be called ===" << endl;
    return 0;
}</code></pre>
                                </div>

                                <h3>Virtual Function Table (vtable):</h3>
                                <div class="vtable-explanation">
                                    <p>Each class with virtual functions has a virtual function table (vtable) that contains pointers to the virtual functions. When a virtual function is called, the program looks up the correct function in the vtable.</p>
                                    
                                    <div class="vtable-diagram">
                                        <h4>How vtable works:</h4>
                                        <ol>
                                            <li>Each object has a pointer to its class's vtable</li>
                                            <li>Virtual function calls are resolved at runtime</li>
                                            <li>The correct function is called based on the object's actual type</li>
                                        </ol>
                                    </div>
                                </div>

                                <h3>Rules for Virtual Functions:</h3>
                                <div class="virtual-rules">
                                    <ul>
                                        <li>Virtual functions cannot be static</li>
                                        <li>Virtual functions cannot be inline</li>
                                        <li>Constructors cannot be virtual</li>
                                        <li>Destructors should be virtual in base classes</li>
                                        <li>Pure virtual functions make the class abstract</li>
                                    </ul>
                                </div>

                                <div class="info-box">
                                    <i class="fas fa-exclamation-triangle"></i>
                                    <p><strong>Important:</strong> Always declare destructors as virtual in base classes to ensure proper cleanup when deleting objects through base class pointers.</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </section>

                <div class="navigation-buttons">
                    <a href="basics.html" class="btn btn-secondary">
                        <i class="fas fa-arrow-left"></i> Previous: Basics
                    </a>
                    <a href="advanced.html" class="btn btn-primary">
                        Next: Advanced <i class="fas fa-arrow-right"></i>
                    </a>
                </div>
            </div>
        </main>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="script.js"></script>
</body>
</html>
